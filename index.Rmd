---
title: "Reactor"
subtitle: "Unit Testing Shiny App Reactivity"  
author: 
  - "Jonathan Sidi"
date: 'R/Pharma 2020<br/>`r Sys.Date()`<br/><br/>https://bit.ly/36fTYFs'
output:
  xaringan::moon_reader:
    lib_dir: libs
    css: ["css/xaringan-themer.css", "css/colours.css","css/title.css"]
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      beforeInit: "js/macros.js"
---

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
```

```{r xaringan-themer, include=FALSE, warning=FALSE}
library(xaringanthemer)
style_mono_light(base_color = "#23395b")
```

```{r share-again, echo=FALSE}
xaringanExtra::use_clipboard()
xaringanExtra::use_share_again()
```

# Motivation

.pull-left[
The ability to **diagnose** and **resolve** cascading reactivity in Shiny applications is an integral part of good application development preventing a waste of resources and negative user experiences.
]

.pull-right[
![](https://media.giphy.com/media/xUPGcvrXl7RBEp3zC8/giphy-downsized.gif)
]


---

# Unit Testing

  - Unit testing creates a framework that improves collaboration across multiple developers, enables coverage tracking across varying scenarios and promotes a safer production environment. 

  - This is commonly used in R package development to validate source code. 
  
  - In Shiny applications the ability to __diagnose and resolve reactivity problems through unit testing is lacking__.

---
# Solution

- The __{reactor}__ package solves this issue by creating a new framework that adds reactivity expectations to unit testing in R.

- With __{reactor}__ defensive development can by applied to Shiny applications to both plan and preserve reactivity with multiple developers working on the application in a production environment.

## Where it's at

GitHub: https://github.com/yonicd/reactor

```{r,eval = FALSE}
remotes::install_github('yonicd/reactor')
```

---
### How does {reactor} fit in with other packages?

Currently there are not a lot of packages that deal with unit testing and specifically testing reactivity in Shiny applications. The two primary methods are:

.pull-left[
__{shinytest}__ 
- Checks that inputs change properly and that UI behaves consistently.
- Integrates with __{testthat}__
- Integrates with Continous Integration
]

.pull-right[
__{shiny}::testServer__

Built in testing script for __{shiny}__ that works with shiny modules to create testing environment to verify reactive outputs are as expected.
]

<message-blockquote>These packages work well for testing that reactivity has occurred and that the output is as expected, but they do not test if the reactivity is creating problems with the app integrity and the second order effects such as repetitive or cascading reactivity.</message-blockquote>

---

# Reactor Testing Workflow

The __{reactor}__ workflow is split into three parts

1. Serving a Shiny application nested with __{whereami}__ calls via __{processx}__.

![:scale 85%](media/reactor_01.svg)
---
# Reactor Testing Workflow

2\. "Drive" the Shiny application with pre-specified commands using headless browsing via __{Rselenium}__. As the application is reacting to the commands __{whereami}__ logs the reactivity events.

![](media/reactor_02.svg)

---
# Reactor Testing Workflow

3\. Once the prespecified commands have completed the __{whereami}__ log file is used by expectations of reactivity in a __{testthat}__ environment.

![](media/reactor_03.svg)
---

# Shiny App

The rest of the slides explain how __{reactor}__ workflow is used through a simple Shiny app. 

The app will have two UI elements:

  - A numeric input (`input$n`) that the user can change.
  - A plot output showing the `histogram(runif(input$n))` which observes changes to `input$n`

On the server side we will add a new element for logging reactivity using __{whereami}__.

---

```{r,eval = FALSE}
# Global Variables
n <- 200

# Define the UI
ui <- shiny::bootstrapPage(
  shiny::numericInput('n', 'Number of obs', n),
  shiny::plotOutput('plot')
)

# Define the server code
server <- function(input, output) {

  shiny::observe({
    output$plot <- shiny::renderPlot({
      whereami::whereami(tag = 'hist') #<<
      graphics::hist(stats::runif(input$n))
    })
  })
}

# Return a Shiny app object
shiny::shinyApp(ui = ui, server = server)

```

--

<warn-blockquote> What does `whereami::whereami(tag = 'hist')` do? </warn-blockquote>


---

# whereami ![:scale_right 15%](https://github.com/yonicd/hex/raw/master/images/logos/whereami.png)
__{whereami}__ is a package that logs the locations where command in an R session were invoked and their source location.

Using __{whereami}__ with shiny is simple. 

In the app file place __cat_where(whereami(tag = 'hist'))__ on the server side.

Every time the rendering application hits the line it will print to console indicating which line has been hit accompanied by a counter.

```r
── Running renderPlot(...) at shiny.R#15 (1) ─────────────────
── Running renderPlot(...) at shiny.R#15 (2) ─────────────────
```

Using the __tag__ argument will log the counter to a specific internal label and allow multiple concurrent counters.

---
## Shiny whereami example
.center[![:scale 85%](https://github.com/yonicd/whereami/blob/media/whereami_shiny.gif?raw=true)]

<message-blockquote> Save the code to file to run the example </message-blockquote>
---

# Running our App

Now that we have an app with a __{whereami}__ call in the server script we need to run it in a child R process. 

.pull-left[
To do this we use __{processx}__ and use a `localhost` port by default.

Don't worry! __{reactor}__ takes care of this machinery for you.
]

.pull-right[
![:scale 80%](https://media.giphy.com/media/xUPGcEghH2dZdXvZSw/giphy-downsized.gif)
]

```{r, echo = FALSE}
details::details(
reactor::runApp_args(
test_path = 'TEST_PATH',
appDir = 'PATH_TO_APP'
),summary = 'Dive deeper: Open to view script')
```

---

# Communicating with the App

To interact with the application that is running in the child process reactor depends on __{RSelenium}__.

When the __{RSelenium}__ is invoked it opens _another_ child process and port on the `localhost` to run the webdriver.

.pull-left[
__{RSelenium}__ uses webdrivers to manipulate content on a web browser.]

.pull-right[
__{reactor}__ comes with functions to set up the proper arguments and preferences to use webdrivers for `firefox` and `chrome`.]

<details>
<summary> Dive deeper: Open to view script </summary>

```r
$args
[1] "--headless" "--width=1280" "--height=800"
$prefs
$prefs$browser.download.folderList
[1] 2
$prefs$browser.download.dir
[1] 'TEST_PATH'
```

</details>
<br>

---

# Interacting with the App
.pull-left[
Now we have two active child processes at the same time and the webdriver can manipulate the running shiny app!

We use __{RSelenium}__ commands and built in __{reactor}__ functions that simplify asynchronous pipelines.
]

.pull-right[
![](https://media.giphy.com/media/xUA7aTTTOEYbozXg2I/giphy-downsized.gif)
]

<details><summary>Side Note</summary>
<ok-blockquote>
{reactor} works with {crrri} or {crrry} much the same way it works with {RSelenium}. More info in the package GitHub repository.
</ok-blockquote>
</details>
<br>

---

# Test Reactor

To help simplify things `test_reactor` ties all these concepts together. 

```{r, eval = FALSE}
reactor::test_reactor(
  expr          = driver_commands,
  test_driver   = reactor::firefox_driver(),
  processx_args = reactor::runApp_args(appDir = 'PATH_TO_APP')
)
```
![](media/test_reactor.svg)
---

# Driver Commands

RSelenium driver methods that query and manipulate the shiny app are placed in

```r
driver_commands <- quote({...})
```

The remoteDriver `test_driver` is evaluated in the `test_reator` environment. 

Some example methods:

<details closed>
<summary> <span title='Click to Expand'> Navigate to App </span> </summary>

```{r,eval = FALSE}
test_driver$client$navigate("http://127.0.0.1:6012")
```

</details>
<br>

<details closed>
<summary> <span title='Click to Expand'> Find an Element </span> </summary>

Search for an element on the page, starting from the document root. The located element will be returned as an object of webElement class.

```{r,eval = FALSE}
el <- test_driver$client$findElement(using = "id", value = "n")
```

</details>
<br>

<details closed>
<summary> <span title='Click to Expand'> Execute Script </span> </summary>

Inject a snippet of JavaScript into the page for execution in the context of the currently selected frame.

```{r,eval = FALSE}
test_driver$client$executeScript(script = 'arguments[0].stepUp(4);',args = list(el))
```

</details>
<br>

The next few slides dive into __{reactor}__ and how it interacts with remoteDriver methods, for the full example code [.red[click here]](https://github.com/yonicd/reactor/blob/master/tests/testthat/reactor-reactivity.R#L3_L41).

---

## asynchronous pipelines

__Assigning DOM elements to R objects__

- __wait__ will run the expression only if shiny is not busy
  - When the app initializes we need to __wait__ for the initial UI to load and with it element `numericInput` with the id `n`
- __then__ will run after __wait__ is evaluated.
  - __then__ we find the element using the `id` with the value `n` and assign the DOM element to `el_n` to use in our commands

```{r, eval = FALSE}
el_n <- test_driver%>%
  reactor::wait(
    expr = test_driver$client$findElement(using = 'id', value = 'n')
  )
```

<message-blockquote>This is a bit different from other implementations that use timeout in JavaScript and shinytest in that the timer is built in and will manage for you the time needed to wait.</message-blockquote>

---
__asynchronous pipelines: Retrieving element attributes__

Next we __wait__ for shiny to finish invalidating elements and find the plot associated with `output$plot` and return that element.

The output of __wait__ is then piped into __then__ with the input the expression `elem`. Using this input we can then query attributes of it, in this case we retrieve the src attribute of the image. 

```{r,eval = FALSE}
hist_src <- test_driver%>%
    reactor::wait(
      expr = test_driver$client$findElement(
        using = 'css', 
        value = '#plot > img')
    )%>%
    reactor::then(
      expr = function(elem) {
        elem$getElementAttribute('src')[[1]]
      },
      test_driver = test_driver
    )
```

---
__asynchronous pipelines: Manipulating elements__

Remembering that we assigned `input$n` to `el_n` we can manipulate the value here we increase it by 4.

```{r,eval = FALSE}
test_driver$client$executeScript(
  script = 'arguments[0].stepUp(4);',args = list(el_n)
  )
```

.pull-left[
This mimics the exact actions that you would do manually in the app, causing shiny to go through an invalidation of the reactive elements and updating the histogram.
]

.pull-right[
![](https://media.giphy.com/media/xUPGcmbWEgjx1epbS8/giphy-downsized.gif)
]

---
__asynchronous pipelines: Comparing elements__

Because we changed the histogram we would want compare the new img src attribute with `hist_src`. We use __then2__ to pass 2 elements and use `is_identical` to ask the question is the old src and the new src the same?

  - elem is the piped output from the __wait__ call we are running now
  - elem2 is the object `hist_src` that was assigned originally

```{r,eval = FALSE}
test_driver%>%
  reactor::wait(
    expr   = test_driver$client$findElement(
      using = 'css', value = '#plot > img'
      )
)%>%
reactor::then2(
  elem2 = hist_src,
  expr   = function(elem,elem2){
    reactor::is_identical(
      elem$getElementAttribute('src')[[1]],
      elem2
    )
  },
  test_driver = test_driver
)
```
---
# Back to {whereami}

.pull-left[
As you are driving the app with __{RSelenium}__ there is a log file being updated by __{whereami}__ keeping a counter each time it is triggered. 
<br>
<br>
<br>
<br>

Line 15 of the Shiny app was triggered twice consecutively.

<warn-blockquote>Was this the intended action we wanted when developing the app?</warn-blockquote>
]

.pull-right[
![](media/whereami.svg)

|tag   |where         |when                 |  count|
|:----:|:------------:|:-------------------:|:-----:|
|hist  |app.R#15      |2020-09-27 10:19:59  |      1|
|hist  |app.R#15      |2020-09-27 10:19:59  |      2|
]

---

# Unit Testing

We now have a log file on disk that we can use to query expectations of app reactivity.

![](media/testing.svg)


---
# Expectations

__{reactor}__ comes with its own set of expectations that are built for __{whereami}__ outputs and can be used inside __{testthat}__.

Using the __{whereami}__ log output structure we indicate the `tag` we want to use (`'hist'`) and the expected counter value (`1`).

```{r,eval = FALSE}
testthat::describe('reactive test',{
  it('reactive hits in plot reactive chunk',{
    reactor::expect_reactivity(
      object = hist_counter, tag = 'hist',count =  1
    )
  })
})
```

If `FALSE` the following error message is returned

```{r,eval = FALSE}
Error: The tag 'hist' has reactivity count of 2, not 1.
```

---

### Fixing our App
<warn-blockquote> __Bad App__ `renderPlot` is in an `observe` which is triggered every time the app is invalidated </warn-blockquote>
```{r,eval = FALSE}
shiny::observe({ #<<
  output$plot <- shiny::renderPlot({
    whereami::whereami(tag = 'hist')
    hist(stats::runif(input$n))})
  })
```

<ok-blockquote> __Good App__ `renderPlot` is in an `observeEvent` which is triggered only when `input$n` is invalidated. </ok-blockquote>

```{r,eval = FALSE}
shiny::observeEvent(input$n,{ #<<
  output$plot <- shiny::renderPlot({
    whereami::whereami(tag = 'hist')
    hist(stats::runif(input$n))})
  })
```

---

# Directory Structure

  - The testing file for __{reactor}__ is set up exactly the same as a __{testthat}__ file, except that instead of using the naming convention `test-*.R` you can use `reactor-*.R`. 

```r
tests
├── testthat
│   ├── reactor-reactivity.R # Reactive Tests
│   └── test-loads.R # Package tests
└── testthat.R
```

  - This serves the purpose of making it simpler to isolate reactivity tests from the other tests that may be in a package.
  
  - Reactivity tests can be called directly by using `reactor::test_app()`

---

# Unit Tesing Reactivity ![:scale_right 25%](https://media.giphy.com/media/l3UcA1HpL5kLuiWOc/giphy.gif)
<br>
![](https://github.com/yonicd/reactor/raw/media/example.gif)

---

# Go forth and test your apps!

.pull-left[
What __{reactor}__ gives you:

- Simplifies diagnosing reactivity issues in Shiny
- Creates framework to store and reproduce testing of Shiny Apps
- Can be applied in Continuous Integration environments
- Creates safer Shiny app development practices for teams to collaborate.
]

.pull-right[
<br/>
<br/>
![](https://media.giphy.com/media/26gs78HRO8sOuhTkQ/giphy-downsized.gif)
]
<br/>
### .center[Thank you :)]


